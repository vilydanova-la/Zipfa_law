Глава 1
Модели данных
Переход от неформального к формальному
существенно неформален.
М. Р. Шура-Бура
Модель данных — это набор абстракций и приёмов, с помощью которых мы
пытаемся имитировать понятия реального мира. Модель данных напрямую ничего не говорит ни о производительности базы данных, ни о надёжности, ни
о возможности масштабирования. Тем не менее именно модель в большинстве
случаев является ключевым фактором выбора платформы.
1.1. Реляционные БД
Ещё в начале XXI века само понятие «база данных» подразумевало именно
реляционную базу. Появившись в 70-х годах XX века, реляционные платформы
до сих пор остаются наиболее распространёнными и универсальными. В рейтинге популярных баз данных, который ведёт портал db-engines.com, первые четыре места занимают именно реляционные СУБД — Oracle, MySQL, Microsoft SQL
Server и PostgreSQL, а среди 50 самых популярных баз данных реляционных —
больше половины.
Исторический экскурс
В 50-е и 60-е годы XX века главными покупателями ЭВМ были крупный бизнес и государственные учреждения, которые привыкли работать с каталогами
и картотеками. Именно эти инструменты управления большими объёмами информации легли в основу первых навигационных моделей данных — иерархической и более поздней сетевой.
Основным объектом навигационных моделей был тип сегмента (segment
type) — структура, описывающая некий объект реального мира: пациента, товар,
договор. Тип сегмента состоял из полей (fields), содержавших данные,— например
21
Глава 1. Модели данных
фамилию или год рождения. Экземпляр сегмента (segment instance) описывал конкретный объект.
В иерархической модели у каждого типа сегмента был родительский тип — например, «родителем» каждого товара мог быть производитель. Хорошим примером иерархической модели может служить файловая система, которой мы пользуемся каждый день. Важным отличием сетевой модели от иерархической было
то, что сегмент мог иметь несколько «родителей».
Для доступа к данным программист получал набор функций, работавших в терминах указателей на конкретные «карточки» — экземпляры сегментов. Типичными функциями были «найти сегмент и указать на первый экземпляр», «перейти
к следующему экземпляру», «перейти к родительскому (или дочернему) экземпляру», «найти экземпляр, удовлетворяющий условию».
Навигационные СУБД прекрасно решали задачи, которые ставил перед ними бизнес, особенно с учётом ограниченной мощности компьютеров того времени. Яркими примерами таких платформ могут служить IMS (IBM) и ADABAS
(Software AG). Несмотря на то что «золотым веком» навигационных платформ
считаются 60-е годы прошлого столетия, они развивались вплоть до 80-х годов —
достаточно вспомнить такие продукты, как dBase, FoxBase, Clipper.
Началом эры реляционных баз данных принято считать статью «Реляционная
модель данных для больших совместно используемых банков данных» («A Relational Model of Data for Large Shared Data Banks»), опубликованную в 1970 году
Эдгаром Коддом (Edgar Frank Codd).
С точки зрения самой структуры данных предложенная Коддом реляционная
модель практически не отличалась от навигационной — все отличия касались
способов описания структуры и доступа к данным. По мнению Кодда, главный
недостаток существующих на тот момент систем — зависимость приложений
от физической организации данных. В статье приводится три зависимости:
• Зависимость от порядка, в котором записаны данные. Если приложение
предполагает, что данные записаны в определённом порядке (например,
фамилии клиентов отсортированы по алфавиту), то нарушение этого порядка приведёт к ошибкам в работе приложения.
• Зависимость от индексации. Индексом называется вспомогательная структура данных, служащая для ускорения поиска. Если приложение рассчитано
на использование какого-то индекса, то уничтожение этого индекса приведёт к неработоспособности приложения, и наоборот — использование нового индекса потребует изменения кода.
22
1.1. Реляционные БД
• Зависимость от путей доступа. Каждый сегмент хранится в некотором файле, и перемещение сегмента в другой файл или добавление в этот же файл
нового сегмента может нарушить работу приложения.
Эдгар Кодд предложил строить описание модели и язык доступа к данным
на базе математической теории, называемой реляционной алгеброй. Решение
оказалось крайне успешным и обеспечило, пусть и не сразу, стремительный взлёт
реляционных СУБД и их безусловное доминирование на протяжении многих лет.
Любопытно, что многие навигационные системы обзавелись реляционными
фасадами, тем самым значительно продлив свою жизнь. Так, например, у ADABAS
появились компоненты, позволяющие писать запросы к базе на языке SQL,
из FoxBase вырос FoxPro, а Db2/i до сих пор, помимо SQL, поддерживает навигационный стиль программирования на языке RPG.
Реляционная алгебра
Слово «реляционная» произошло от слова «relation», отношение. Это математическая структура, определяющая взаимосвязи объектов. Рассмотрим, например, отношение «кратно». Это бинарное (или двухместное) отношение, то есть
отношение, у которого два атрибута. Запись { делимое: 16, делитель: 4 } говорит о том, что кортеж (то есть набор атрибутов) находится в отношении «кратно».
Атрибутов у отношения может быть сколько угодно — от одного и больше1
.
И вместо того чтобы формально определять отношения через математические
функции, мы можем перечислить все кортежи, то есть наборы атрибутов, находящиеся в отношении. Например, если определить бинарное отношение «Квартет»
с атрибутами «музыкант» и «инструмент», то кортеж будет в этом отношении, если в квартете играет «музыкант» на «инструменте»:
{
"квартет": [
{"музыкант":"мартышка", "инструмент":"скрипка"},
{"музыкант":"осёл", "инструмент":"альт"},
{"музыкант":"козёл", "инструмент":"скрипка"},
{"музыкант":"мишка", "инструмент":"бас"}
]
}
Если вынести названия атрибутов в заголовок, получится привычная таблица:
1 Теоретически возможно отношение без атрибутов, а некоторые платформы позволяют даже создать таблицу без колонок, но практического смысла такая структура лишена.
23
Глава 1. Модели данных
музыкант инструмент
мартышка скрипка
осёл альт
козёл скрипка
мишка бас
Как правило, когда говорят о реляционных базах данных, вместо терминов
теории множеств используют интуитивно понятные термины:
Русский Английский Русский Английский
термин термин интуитивный интуитивный
теории множеств теории множеств термин термин
Отношение Relation Таблица Table
Представление View
Атрибут Attribute Столбец, Column,
колонка, поле field
Кортеж Tuple Строка, Row,
запись record
Несмотря на очевидные сходства, объекты реляционных баз данных отличаются от «идеальных» математических объектов:
• Строки в таблице упорядочены — как правило, по времени добавления
в таблицу или по времени изменения, хотя существуют платформы, которые упорядочивают строки в порядке возрастания или убывания значений
какого-либо столбца. При выборке порядок строк можно изменить. Кортежи в отношении не упорядочены, т. к. отношение — это множество.
• Столбцы (поля) в строке упорядочены; порядок столбцов в строке соответствует порядку их перечисления в команде создания таблицы. В некоторых
платформах порядок перечисления столбцов может влиять на объём, занимаемый данными, и на скорость обработки. При выборке порядок столбцов
можно изменить. Атрибуты в кортеже не упорядочены, т. к. кортеж — это
тоже множество, как и отношение.
• В таблице может быть несколько одинаковых строк, в то время как все кортежи отношения (элементы множества) различны.
• В таблице могут быть «скрытые», или «системные», столбцы — например,
временны́е метки или указатели на физическое расположение строки.
24
1.1. Реляционные БД
Реляционная алгебра определяет операции над отношениями, результаты которых также являются отношениями. Количество операций бесконечно, однако
практические требования по обработке данных покрываются ограниченным набором реляционных операций:
• переименование (rename) — изменение имён отношений и атрибутов (таблиц и колонок) в рамках текущей операции;
• проекция (projection) — выборка подмножества колонок1
;
• фильтрация (selection) — выборка подмножества строк, соответствующих
заданному условию;
• соединение (join) — составление новых строк, состоящих из колонок соединяемых таблиц или представлений. Соединение — пожалуй, наиболее мощная и востребованная возможность реляционных баз данных. Теория множеств определяет соединение как «подмножество декартова произведения»,
но проще представить себе его как формирование новых кортежей, часть атрибутов которых берётся из первого отношения, а часть — из второго;
• объединение (union) — выборка, в которую попадают строки и из первой,
и из второй объединяемых таблиц, причём строка, существующая в обеих
таблицах, попадёт в выборку единственный раз. В отличие от «чистой» теории множеств, в реляционных БД есть и объединение без исключения дубликатов (union all);
• разность (complement) — выборка, в которую попадают строки, которые
есть в первой таблице, но отсутствуют во второй таблице;
• пересечение (intersection) — выборка строк, которые есть и в первой, и во
второй таблице;
• агрегация (aggregation) — расчёт «обобщённых» строк на базе значений
нескольких строк исходной таблицы.
В реляционных платформах операции над данными записываются на языке
SQL (structured query language). Аббревиатура «SQL» читается либо как «эс-куэль», либо как «сиквел» — в память о названии SEQUEL, под которым этот язык
впервые увидел свет в СУБД IBM System R. Любопытно, что сегодня SQL считается
языком программирования, хотя создавался он как язык конечного пользователя.
Пусть у нас есть таблица с участниками квартета, где музыкальный инструмент обозначен специальным кодом (ключом), а также таблица со справочником
1 Здесь и далее будем использовать терминологию реляционных БД; описания останутся верными
и в том случае, если заменить эти термины терминами теории множеств.
25
Глава 1. Модели данных
музыкальных инструментов. Надо получить названия инструментов и количество музыкантов, играющих на этих инструментах. Запрос, решающий описанную
задачу, мог бы выглядеть так:
select
  i.name as "Инструмент",
  count(*) as "К-во музыкантов"
from
  quartet q join instrument i 
    on q.instrument_id=i.id
group by i.name
Переименование столбцов
Соединение
Агрегация
Переименование таблиц
Описание языка SQL выходит за рамки данной книги, отметим лишь один фундаментальный принцип. SQL — язык декларативный, а не императивный. Это
значит, что программа на языке SQL (обычно вместо слова «программа», program, используются термины «запрос», query, или «утверждение», statement) описывает результат, который программист хочет получить, в терминах операций
над множествами (таблицами), но не описывает алгоритм получения этого результата.
За преобразование запроса в алгоритм отвечает компонент СУБД, называемый «оптимизатором» (optimizer), а сам процесс превращения запроса в алгоритм называется не компиляцией, а оптимизацией. Алгоритм, полученный в результате оптимизации, называется планом запроса.
Одни и те же операции могут быть выполнены несколькими способами и в разном порядке, то есть в зависимости от внешних условий СУБД может сгенерировать для одного и того же запроса совершенно разные планы.
Как и в случае с императивными языками, один и тот же результат может быть
получен при помощи разных запросов. Изменение логики запроса может оказать
гораздо более сильное влияние на производительность, чем выбор последовательности действий для реализации конкретного запроса.
Пусть, например, у нас есть таблица, каждая строка которой соответствует накладной. Колонками этой таблицы являются номер накладной (id) и идентификатор клиента (client_id). Задача состоит в том, чтобы выбрать клиентов, которые
покупали товар несколько раз. Ниже приведены два решающих её запроса.
Первый запрос пытается каждой накладной при помощи операции соединения поставить в соответствие накладную с другим идентификатором, выписанную тому же покупателю, а потом из полученного списка пар накладных выбрать
разных покупателей:
26
1.1. Реляционные БД
select
distinct l1.client_id
from
invoice i1 join invoice i2 on i1.client_id=i2.client_id
where l1.id<>l2.id
Второй запрос из всего списка накладных выбирает разных покупателей, а потом оставляет только тех, кто встретился два раза или больше:
select
client_id
from invoice
group by client_id
having count(distinct id)>1
Скорее всего, второй запрос будет исполнен в несколько раз быстрее первого, независимо от качества оптимизации. Программисту, работающему с базами
данных, следует научиться строить и понимать планы запросов. Подробнее о них
поговорим в главе 4 «Обработка данных».
Ограничения целостности
Ещё один мощный инструмент, который реляционные базы данных предоставляют разработчику, — декларативные ограничение целостности, то есть ограничения, для соблюдения которых не нужно писать код — достаточно их описать.
Запрет неопределённых значений (not null) запрещает записывать в поле
неопределённое значение, null. В некоторых источниках можно встретить описание null как «пустого значения», но это неверно. Пустая строка ('') — определённое значение, в отличие от null1
.
Первичный ключ (primary key) — это поле (или набор полей), которые уникально идентифицируют строку. Если какой-то набор полей объявлен как первичный ключ, то в ни в одном поле из этого набора не может быть неопределённых значений, и не может быть двух строк, в которых значения полей этого
набора одинаковы.
Большинство реляционных платформ позволяют создавать таблицы без первичного ключа, однако почти у каждой таблицы первичный ключ всё же есть.
На практике в качестве первичных часто используются суррогатные ключи
(surrogate keys). Суррогатом называется значение, не имеющее никакого смысла,
единственное свойство которого — уникальность. Для создания таких значений
1 Кроме СУБД Oracle, где пустая строка — то же самое, что и null.
27
Глава 1. Модели данных
в базах данных предусмотрены специальные механизмы — последовательности
(sequences), поля с автоинкрементом (autoincrement columns) или генераторы
глобально уникальных значений (uuid).
Любопытно, что одно и то же значение может быть как суррогатом, так
и бизнес-ключом. Так, например, Пенсионный фонд России генерирует для каждого гражданина девятизначный1
суррогатный ключ — СНИЛС (страховой номер индивидуального лицевого счёта). В то же время для любой базы данных,
эксплуатируемой вне ПФ РФ, СНИЛС уже является бизнес-ключом, поскольку поступает в систему извне.
Споры между сторонниками суррогатных и натуральных (осмысленных) ключей не утихают. Основным недостатком суррогатных ключей считается усложнение структуры базы и увеличение пространства, занимаемого данными.
В то же время лишь суррогатный ключ может гарантировать наличие определённых значений и уникальность этих значений. Можно попытаться идентифицировать человека по полному имени, дате и месту рождения, но, во-первых,
ссылаться на такой ключ неудобно, а во-вторых, дубликаты возможны. И даже
такой идентификатор, как ИНН (индивидуальный номер налогоплательщика)
физического лица, который должен быть уникальным и неизменным согласно
Налоговому кодексу, может измениться — автору известен такой случай! Изменение первичного ключа — очень тяжёлая операция, а многие платформы такую
операцию вообще не поддерживают.
Уникальный ключ (unique) — это поле или набор полей, в котором не может быть одинаковых значений в двух и более строках. В отличие от первичного
ключа, уникальное поле может иметь неопределённое значение, если для него
не задано ограничение not null. Ограничение уникальности хорошо подходит
для полей, значения которых должны быть уникальны, но создаются вне приложения, — например, ИНН или СНИЛС.
До недавнего времени null не участвовал в определении уникальности, то есть
в колонке, на которую наложено ограничение уникальности, могло содержаться
сколько угодно неопределённых значений. Стандарт SQL:2023 добавил возможность считать уникальным значением и null тоже, и в колонке с таким ограничением может быть не больше одного неопределённого значения.
Проверка значения (check) ограничивает список значений, допустимых в поле, некоторым диапазоном. Например, можно проверять, что количество товара
1 СНИЛС состоит из 11 цифр, но последние две цифры представляют собой контрольную сумму.
28
1.1. Реляционные БД
на складе неотрицательно или что в поле «пол» не записано ничего, кроме «M»
и «F». В поле с проверкой может быть записано и неопределённое значение, null,
если только на колонку не наложено дополнительное ограничение.
Внешний ключ (foreign key) — поле или набор полей, которые содержат первичный ключ другой таблицы. Таблица с внешним ключом называется дочерней
(child), а таблица, на которую она ссылается, — родительской (parent). Таблица может ссылаться и сама на себя — например, в таблице «сотрудники» может
быть ссылка на руководителя, который также является сотрудником и находится
в той же таблице.
Если в базе данных объявлен внешний ключ, то база не позволит не только
вставить в дочернюю таблицу строку, ссылающуюся на несуществующий ключ
родительской таблицы, но и удалить строку из родительской таблицы, если на неё
есть ссылки из дочерних таблиц. Возможны также варианты, когда при удалении строки из родительской таблицы все ссылающиеся на неё строки дочерних
таблиц также удаляются (каскадное удаление), либо во все строки дочерней таблицы, ссылавшиеся на удалённую строку, в поля внешнего ключа записывается
null (каскадное обнуление).
Вспомогательные структуры данных
Одним из ключевых достоинств реляционных платформ является независимость программ, работающих с базой данных, от физического представления данных. Эта особенность позволяет создавать вспомогательные структуры данных.
Эти структуры содержат подмножества данных, хранимых в таблицах, и их
уничтожение не приводит к потере информации. Поскольку в большинстве баз
данных чтение и поиск выполняются значительно чаще, чем запись, использование вспомогательных структур позволяет ускорить чтение ценой замедления
записи и использования дополнительного пространства для хранения.
Создать вспомогательную структуру должен администратор БД, однако уже
существуют системы, способные подсказывать, пусть и не всегда верно, какие
именно вспомогательные структуры могут оказаться полезными.
К вспомогательным структурам относятся индексы (indexes) и снимки (snapshots, или materialized views).
Любой поиск в базе данных теоретически может быть выполнен путём полного просмотра таблицы. Но многие задачи поиска, особенно если требуется извлечь относительно небольшой объём данных, решаются значительно быстрее
29
Глава 1. Модели данных
за счёт индексирования. В индексе значения поля (или набора полей) упорядочены, а для поиска элемента в упорядоченном списке разработан ряд эффективных
алгоритмов — например, двоичный поиск (binary search) или интерполяционный поиск (interpolation search).
Большинство индексов в реляционных БД построены с использованием B-деревьев, однако возможно и использование других структур. Индексы решают две
важные задачи:
• ускорение доступа к данным;
• поддержка уникальности значений.
Если в таблице создан первичный ключ или ограничение уникальности, то
каждый раз при добавлении строки БД должна просмотреть все значения полей,
чтобы проверить, что вставляемое значение действительно уникально. Этот просмотр можно быстро выполнить только с использованием индекса, поэтому если
ключевое поле в момент создания ограничения не проиндексировано, то индекс
по ключевому полю будет создан автоматически.
Индекс по первичному ключу называется первичным (primary index), однако
на таблице может быть создано произвольное количество вторичных индексов
(secondary indexes) для ускорения поиска по неключевым атрибутам.
Представление (view) — это сохранённый запрос (select) на языке SQL. Представление может использоваться в запросах так же, как обычная таблица, но все
операции, описанные в представлении, каждый раз при выполнении запроса, обращающегося к этому представлению, будут выполнены заново.
В отличие от «обычного» представления, снимок (snapshot), или материализованное представление (materialized view), сохраняет результат исполнения запроса над базовыми таблицами и использует сохранённые данные точно
так же, как данные базовых таблиц. Единственная разница между снимком и таблицей состоит в том, что для изменения данных в снимке необходимо изменить
данные в таблицах, на базе которых этот снимок построен, а затем обновить снимок — автоматически или вручную.
Диаграммы «сущность—связь»
Работа с реляционной БД начинается с проектирования схемы данных, то есть
набора объектов и связей между ними, а также их отображения на таблицы
и внешние ключи. Для проектирования на бумаге или в системах автоматизированного проектирования (ERWin, Rational Rose, Power Designer, ModelRight и др.)
30
1.1. Реляционные БД
используются диаграммы «сущность—связь» (entity-relationship diagram), где
сущности (объекты) изображаются как блоки, а связи между ними — как линии
между блоками Диаграммы используются и для проектирования физической модели данных, и тогда блоки обозначают таблицы, а линии — внешние ключи.
В большинстве случаев логическая модель совпадает с физической, то есть
каждой сущности соответствует таблица, а каждой связи — внешний ключ. Однако существуют и исключения, например:
• в реляционной модели невозможно непосредственно создать связь «многие
ко многим»;
• несколько сущностей (например, справочников) могут храниться в одной
таблице;
• одна сущность может распадаться на несколько таблиц: часть атрибутов
в одной таблице, часть — в другой;
• одна таблица может хранить текущее состояние объекта, а другая — историю состояний.
Клиент
(Customer)
Адрес
(Address)
На диаграмме выше изображены две таблицы — клиент (customer) и адрес
(address), причём таблица адресов ссылается на таблицу клиентов, то есть содержит внешний ключ. В данном случае логическая модель совпадает с физической.
Существует несколько нотаций для диаграмм, однако наиболее распространённая — «вороньи лапки» (crow’s foot). Для моделирования «на салфетке» достаточно линий, как на рисунке вверху — «лапка» цепляется к дочерней сущности,
а линия без декораций — к родительской. Однако полная нотация включает в себя несколько вариантов окончания линий, указывающих на количество связей:
Изображение Название Пояснение
Много
В дочерней таблице должна быть минимум
одна строка для каждого ключа родительской
Один или много таблицы. В реляционных СУБД не существует
декларативного правила для проверки
этого условия
31
Глава 1. Модели данных
Изображение Название Пояснение
Допускаются строки в родительской
Ноль или много таблице, на которые не ссылается
ни одна строка дочерней таблицы
Один То же, что и окончание без декораций
Внешний ключ не может быть пустым
Один и только один (поле с внешним ключом объявлено как
not null)
Ноль или один Внешний ключ может быть пустым
Некоторые средства разработки (например, ERWin) могут также менять форму
блока для таблицы: блок с закруглёнными углами означает наличие мигрирующего ключа.
cust_id FK
Customer Address Customer Address
cust_id addr_id cust_id cust_id FK
cust_addr_no
Пусть, например, в базе есть таблица «клиент» с суррогатным ключом. Для дочерней таблицы «адрес» мы можем также генерировать суррогатный ключ,
а ключ клиента добавить обычным полем — внешним ключом. В этом случае диаграмма будет выглядеть как на рисунке слева.
Другой способ идентификации адреса — идентификатор клиента и номер адреса для этого клиента, то есть внешний ключ является частью первичного ключа. В этом случае диаграмма будет выглядеть как на рисунке справа.
Классическая ситуация, когда без миграции ключей не обойтись, — вспомогательные1
таблицы, реализующие связь «многие ко многим». Самый распространённый пример такой модели— сотрудники и проекты, когда в проекте работают
несколько сотрудников, а сотрудник может участвовать в нескольких проектах
одновременно. Логическая модель содержит два объекта и связь «многие ко многим»:
1 В разговорной речи такие таблицы называют также «развязочными».
32
1.1. Реляционные БД
Сотрудник
emp_id
Проект
prj_id
В физической модели появляется вспомогательная таблица с мигрировавшими ключами:
Employee emp2prj
emp_id emp_id FK
prj_id FK
Project
prj_id
Автору встречались попытки ввести во вспомогательную таблицу собственный суррогатный первичный ключ и наложить на мигрировавшие ключи ограничение уникальности вместо ограничения первичного ключа, но такая структура лишь приводит к дополнительным расходам памяти и процессорного времени,
не давая никакого выигрыша.
Нормальные формы
При моделировании реляционных данных сложились некоторые правила, призванные улучшить модель. Эти правила оформлены в виде требований и называются «нормальными формами» (normal forms), а приведение модели данных
к нормальной форме называется «нормализацией».
Рассмотрим таблицу, в которой хранятся остатки на счетах клиентов банка:
Код клиента Клиент
42
{ "клиент": {"имя": "Василий","счёт": [
{ "название": "моя карта", "код продукта": 800,
"тип": "текущий счёт", "остаток": 10000 },
{ "название": "кредит", "код продукта": 917,
"тип": "автокредит", "остаток": -75200 }
] } }
91
{ "клиент": { "имя": "Анна", "счёт": [
{ "название": "моя карта", "код продукта": 800,
"тип": "текущий счёт", "остаток": 7000 },
{ "название": "на чёрный день", "код продукта": 954,
"тип": "вклад", "остаток": 30000 }
] } }
33
Глава 1. Модели данных
Вопреки сложившемуся стереотипу, современные реляционные СУБД умеют
не просто хранить большие тексты (CLOB — Character Large OBject), но и понимать структуру хранимых текстов (XML или JSON) и корректно работать с этой
структурой. Однако в реляционной модели всё же принято хранить каждый атрибут отдельно.
Итак, говорят, что таблица (отношение) находится в первой нормальной
форме, если все её колонки содержат атомарные значения, то есть такие значения, части которых не имеют значения сами по себе1
. Значения ключа атомарны,
т. к. сами по себе цифры «4» и «2» бессмысленны, а значения поля «Клиент» — нет.
После приведения к первой нормальной форме таблица примет вид:
Код Код
клиента Имя Название продукта Тип Остаток
42 Василий моя карта 800 текущий счёт 10 000
42 Василий кредит 917 автокредит −75 200
91 Анна моя карта 800 текущий счёт 7 000
91 Анна на чёрный день 954 вклад 30 000
Очевидно, что поле «Код клиента» не является первичным ключом этой таблицы, т. к. его значение одинаково для всех строк, относящихся к одному клиенту.
Первичным ключом будет набор полей «Код клиента, Название».
Работать с такой таблицей неудобно. Во-первых, нет простого способа извлечь
из таблицы информацию о клиенте, не относящуюся к его счетам, — например,
имя. Для этого придётся выполнять группировку по идентификатору клиента,
и совершенно не очевидно, что делать, если в строках с одним и тем же идентификатором окажутся разные имена. Способов проследить, чтобы значения поля
«имя» у всех строк с одинаковым идентификатором были одинаковыми, не существует. Во-вторых, возникают аномалии записи:
• если клиент решит сменить имя, то придётся обновлять столько строк,
сколько у него счетов;
• невозможно сохранить информацию о клиенте, если у него нет ни одного
счёта.
1 Ценность частей значения — предмет разумных договорённостей. Теоретически можно как считать атомарным значением текст, содержащий структурированные данные, так и вкладывать отдельное значение в каждый разряд ключевого поля.
34
1.1. Реляционные БД
Для устранения этих аномалий таблица должна быть разбита на две другие
таблицы, каждая из которых является проекцией исходной таблицы. Таким образом, процесс нормализации можно также назвать процессом проектирования.
Посмотрим, от чего зависит значение каждого поля:
первичный ключ
код клиента
название
имя
остаток
тип
код продукта
Значения полей «код продукта», «тип» и «остаток» зависят от значения первичного ключа. Если не существует подмножества полей первичного ключа, определяющего значения этих полей, то такая зависимость называется неприводимой.
Поле «имя» зависит только от части первичного ключа, что ведёт к аномалиям
записи. Говорят, что таблица находится во второй нормальной форме, если значения всех колонок неприводимо зависят от первичного ключа.
Для приведения таблицы ко второй нормальной форме разобьём её на две.
Первая таблица — «Клиент»:
Код клиента Имя
42 Василий
91 Анна
И вторая — «Счёт»:
Код Код Код
счёта клиента Название продукта Тип Остаток
1001 42 моя карта 800 текущий счёт 10 000
1002 42 кредит 917 автокредит −75 200
1003 91 моя карта 800 текущий счёт 7 000
1004 91 на чёрный день 954 вклад 30 000
Обратите внимание на два важных изменения:
• в таблице «Счёт» сохранилось поле «Код клиента», и теперь оно является
внешним ключом на таблицу «Клиент»;
35
Глава 1. Модели данных
• пара полей «Код клиента» и «Название» является уникальным ключом, как
и в оригинальной таблице, но мы ввели дополнительное поле «Код счёта»
с суррогатным ключом.
Проведя нормализацию, мы избавились от части аномалий записи, но аномалии по-прежнему остались:
• если банк расширит линейку продуктов и переименует «текущий счёт»
в «счёт классический», придётся обновить столько строк, сколько «текущих
счетов» открыто в банке;
• невозможно добавить информацию о продукте, не создав хотя бы один счёт;
• если будет закрыт последний счёт с продуктом, то информация о продукте
пропадёт.
Зависимости в таблице «Счёт» выглядят так:
первичный ключ
код счёта
название
остаток
тип
код продукта
Значение первичного ключа однозначно определяет значения всех полей,
то есть таблица находится во второй нормальной форме. Однако на самом деле значение поля «Тип» определяется значением поля «Код продукта», которое,
в отличие от предыдущего примера, не является частью первичного ключа. Зависимость поля «Тип» от первичного ключа называется транзитивной, а если
значения всех полей нетранзитивно зависят от первичного ключа, то говорят,
что таблица находится в третьей нормальной форме. Для приведения таблицы
к третьей нормальной форме разобьём её на две. Первая — «Счёт»:
Код Код Код
счёта клиента Название продукта Остаток
1001 42 моя карта 800 10 000
1002 42 кредит 917 −75 200
1003 91 моя карта 800 7 000
1004 91 на чёрный день 954 30 000
И вторая — «Продукт»:
36
1.1. Реляционные БД
Код продукта Тип
800 текущий счёт
917 автокредит
954 вклад
Обычно, когда говорят «база нормализована», имеют в виду, что все таблицы в ней приведены именно к третьей нормальной форме. Существуют и нормальные формы более высокого порядка, вплоть до шестой, где таблица состоит
из первичного ключа и максимум одного неключевого поля. Однако большинство
примеров таблиц, находящихся в третьей нормальной форме, но не в нормальной форме более высокого порядка, выглядят оторванными от практики. Поэтому
описание нормальных форм более высокого порядка остаётся за рамками книги.
Хотелось бы отметить, что «нормальная форма» и «правильная модель» —
не синонимы. Нормализация всего лишь избавляет нас от избыточности хранения и аномалий записи, но при этом ведёт к увеличению затрат на чтение данных
из-за необходимости соединения таблиц.
В аналитических базах, где запись полностью контролируется, а объём чтения
на несколько порядков превышает объём записи, нередко используются таблицы, находящиеся только во второй или даже только в первой нормальной форме.
Существует несколько методологий проектирования хранилищ данных, которые
по-разному разрешают компромисс между скоростью извлечения данных и компактностью хранения:
Методология Русское название Описание
Таблицы-факты в третьей нормальной
Star schema Схема-«звезда» форме и таблицы-измерения в первой
и второй нормальных формах
Snowflake schema Схема-«снежинка» Таблицы-факты и таблицы-измерения
в третьей нормальной форме
Таблицы-хабы в пятой нормальной
форме, таблицы-связи в четвёртой
Data vault Свод данных нормальной форме и таблицы-сателлиты
в любой нормальной форме —
от первой до пятой
Якорное Таблицы-якоря, атрибуты и узлы в шестой
Anchor modeling моделирование нормальной форме и таблицы-связи
в четвёртой нормальной форме
37
Глава 1. Модели данных
1.2. Хранилища «ключ—значение»
Реляционные платформы практически безраздельно властвовали на рынке баз
данных вплоть до начала 2000-х годов. Однако бурное развитие электронной коммерции и облачных вычислений потребовало появления более производительных, пусть и менее функциональных платформ для управления данными.
Основным требованием к новым платформам была возможность горизонтального масштабирования, то есть увеличения производительности базы данных
не увеличением мощности единственного узла, а добавлением узлов.
Реляционные базы плохо поддаются горизонтальному масштабированию, поскольку, глядя на запрос на языке SQL, невозможно предположить, где находятся
данные, которые потребуются этому запросу. Новое направление развития баз
данных получило название NoSQL, и первыми NoSQL-платформами стали хранилища «ключ—значение». Одним из первых интерфейсов для работы с такими
хранилищами является Java caching API, зарегистрированный в сообществе Javaразработчиков под номером JSR 107.
Java caching API
Интерфейс, появившийся в 2001 году, определяет следующий набор функций
для работы с хранилищем:
• containsKey(K) — проверяет, есть ли в хранилище объект с ключом K;
• get(K) — возвращает объект с ключом K;
• put(K,V)– сохраняет объект V с ключом K;
• putIfAbsent(K,V) — сохраняет объект V с ключом K, только если в хранилище до этого не было объекта с таким ключом;
• remove(K) — удаляет из хранилища ключ K и ассоциированный с ним
объект;
• replace(K,V) — сохраняет объект V с ключом K, только если в хранилище
до этого уже был объект с таким ключом.
Это простейший набор операций, который в литературе часто называется
CRUD (аббревиатура от «create, replace, update, delete»).
Кроме перечисленных простейших операций, интерфейс определяет ряд расширений:
• функции, изменяющие объект, связанный с ключом, и возвращающие
предыдущее значение, — getAndPut(), getAndRemove(), getAndReplace();
38
1.2. Хранилища «ключ—значение»
• функции, считывающие, записывающие или удаляющие сразу несколько
ключей, — getAll(), putAll(), removeAll();
• функции, обеспечивающие атомарные операции сравнения с обменом
(compare-and-set), которые удаляют или заменяют объект только в том случае, если его значение совпадает с заданным, — remove(), replace() (в спецификации JSR 107 имена функций перегружены, и выбор нужной функции
осуществляется по полному прототипу, включающему количество и тип параметров).
Хранилище не имеет никакого представления о структуре объекта, поэтому
оно не может вернуть часть объекта или как-то обработать объект. Единственная возможность обработки объекта на стороне хранилища — методы invoke()
и invokeAll(), позволяющие передать в хранилище класс вместе с кодом его
методов и вызвать эти методы для объектов, ассоциированных с одним или
несколькими ключами соответственно. Естественно, чтобы иметь возможность
выполнить метод invoke(), само хранилище тоже должно быть написано на Java.
На сайте сообщества Java-разработчиков приведён список платформ, реализующих спецификацию JSR 107: Oracle Coherence, Ehcache, Hazelcast, Infinispan, IBM
WebSphere eXtreme Scale, Apache Ignite и др.
Логичным развитием хранилищ «ключ—значение» стало появление документоориентированных СУБД и семейств колонок.
Документоориентированные БД
Документоориентированная база данных — это хранилище «ключ—значение», где значение является не просто набором байтов, а документом, то есть
в самом объекте содержится описание его структуры. Физически документ представляет собой текст в любом из структурированных форматов, например JSON
или XML, или структурированные двоичные данные. Так, Couchbase и Firebase
хранят данные в виде JSON, а MongoDB — в собственном двоичном формате
BSON.
Никаких ограничений на структуру документов не существует, да и структура разных документов, хранящихся в одной коллекции, не обязана совпадать.
Так, например, рядом могут храниться документы-клиенты, документы-счета
и документы-продукты. Разумеется, на практике разработчики стараются хранить в каждой коллекции документы, соответствующие какой-либо одной сущности, но структура этих документов всё равно может отличаться. Например,
39
Глава 1. Модели данных
вместе хранятся клиенты — физические лица и клиенты — юридические лица,
или все документы, которые компания отправляет клиенту, — накладные, счета
и т. д.
Из-за свободы в части модели данных, которую документоориентированные
платформы предоставляют программисту, данные в этих платформах иногда называют «слабоструктурированными» (semi-structured).
Отсутствие ограничений чрезвычайно удобно на этапе разработки, пока
структура документов не устоялась, но доставляет немало проблем при эксплуатации, когда приложение получает документ незнакомой структуры. Поэтому современные документоориентированные платформы (MongoDB, Couchbase)
позволяют задать схему документа, то есть список допустимых полей, а также их
тип и диапазон значений.
Поскольку у базы данных есть доступ к структуре документа, она может возвращать не только документ целиком, но и обработанные данные — например,
отдельные поля документа или даже агрегаты. Кроме того, база может индексировать атрибуты документа и выполнять по ним поиск.
Набор операций, выполняемых над хранимыми данными, отличается от платформы к платформе, и не существует формального критерия, позволяющего однозначно сказать, является платформа документоориентированной или ещё нет.
Обычно документоориентированные СУБД умеют, помимо возврата документа
(или набора документов) целиком по значению ключа, возвращать часть атрибутов документа (проекция), выбирать документы по значениям каких-либо полей (фильтрация), сортировать полученные данные и агрегировать их. Так же
привычно, что документоориентированные СУБД не умеют выполнять операций
над несколькими наборами результатов — пересечения (intersection), вычитания
(complement), объединения (union) и, конечно же, соединения (join).
Вопреки распространённому заблуждению, для эффективной работы с документоориентированной БД модель данных всё же важна. Правда, в отличие
от реляционной модели, подходы к проектированию основываются не на строгой математической теории, а на эмпирических правилах (rules of thumb). Так,
например, MongoDB предлагает несколько вариантов реализации внешних ключей, причём выбор реализации зависит от кардинальности отношения, то есть
от того, сколько дочерних объектов имеется у каждого родительского объекта.
Для отношений небольшой кардинальности, в пределах десятка дочерних
записей, например, телефонов, предлагается включение. Родительский объект
полностью содержит в себе дочерние объекты:
40
1.2. Хранилища «ключ—значение»
{
"name": "Иванов Василий Петрович",
"taxpayer_number": "123-456-7890",
"phones": [
{ "phone_number": "+70001234567" },
{ "phone_number": "+70002345678" }
]
}
Этот подход позволяет одним запросом прочитать все дочерние объекты вместе с родительским, однако добавляет накладные расходы в ситуациях, когда нужны только родительские либо только дочерние структуры. Кроме того, при таком
подходе невозможно выявить ситуацию, когда несколько клиентов указали один
и тот же телефон.
Для отношений кардинальности от десятков до сотен записей предлагается
включение идентификаторов. Например, если нужно сохранить список торговых
точек на маршруте доставки, это можно сделать так:
{
"_id": ObjectID("1A574E90"),
"points_of_sale": [ // идентификаторы точек продаж
ObjectID("DEADBEEF"), ObjectID("FEEDB0AA"),
ObjectID("4455A896"), ...
]
}
При этом каждая запись о точке продаж выглядит, например, так:
{
"_id": ObjectID("DEADBEEF"),
"name": "Мясная лавка",
"address": { "street_name": "Ленина ул.", "house": 33 }
...
}
В отличие от реляционной БД, где информация об экипаже и всех его точках извлекается одним запросом, документоориентированная БД при использовании
такой структуры данных потребует двух запросов: первый извлечёт общую информацию о маршруте, включая список точек доставки, а второй — информацию
обо всех точках по набору их идентификаторов.
Важно понимать, что на самом деле указанная структура реализует отношение
не «один ко многим», а «многие ко многим», то есть через одну и ту же точку может проходить несколько маршрутов. В данном случае контроль уникальности
ссылки должно обеспечить приложение.
Включение идентификаторов допускает и денормализацию — насколько вообще термин «нормальная форма» применим к нереляционным базам:
41
Глава 1. Модели данных
...
"points_of_sale": [ // идентификаторы точек продаж
{ "_id": ObjectID("DEADBEEF"), "name": "Мясная лавка" },
...
]
...
Третий вариант структуры, который рекомендуется применять, когда дочерних записей действительно много,— это хранение ссылок — в точности то же,
что внешние ключи в реляционных базах. Пусть, например, мы хотим сохранить
в базе информацию обо всех маршрутах, по которым экипаж когда-либо проехал.
Тогда запись о маршруте будет выглядеть так:
{
"_id" : ObjectID("FF146ED7"),
"crew_id": ObjectID("1A574E90"),
"start_date": "2020-07-13 11:34:00 MSK"
...
}
В этом случае для работы с информацией о маршрутах конкретного экипажа
потребуется вторичный индекс по полю crew_id. Надо только помнить, что документоориентированная БД не может контролировать корректность ссылок.
Разработчик может комбинировать подходы, — например хранить список дочерних объектов в родительском объекте и одновременно хранить в дочернем
объекте ссылку на родительский объект. Структура данных регулируется исключительно соображениями здравого смысла.
Для работы с базой данных используется либо собственный API (Firebase),
либо REST API, где для описания параметров запроса применяется JSON-документ (Amazon DynamoDB, MongoDB, CouchDB) либо диалект языка SQL (SQL++
в Couchbase). Стандарта на формат запроса не существует — запросы, работающие с одной базой, на другой базе выполнены не будут.
Отдельный подкласс документоориентированных баз данных представляют
платформы для хранения текстовой информации — логов и текстов на естественном языке, например статей или постов в блогах. Эти платформы называются
поисковыми движками (search engines). Помимо классических операций поиска
объектов по идентификатору или значению неключевых атрибутов, они содержат мощные инструменты для полнотекстового поиска, то есть поиска с учётом
морфологии, близости слов и других атрибутов текста на естественном языке.
Наиболее известной библиотекой для полнотекстового поиска является Apache
Lucene, на базе которой выпускаются такие продукты, как Elasticsearch, Solr,
CrateDB. Также широко известны такие платформы, как Splunk и Sphinx.
42
1.2. Хранилища «ключ—значение»
Форматы хранения документов
Самый простой формат файлов для хранения данных — CSV, comma-separated
values. Каждая строка такого файла представляет собой строку данных, а значения атрибутов разделены запятыми или каким-либо другим символом — табуляцией, символом конвейера «|» и др.
Все строки в CSV-файле имеют одинаковую структуру, как строки в таблице
реляционной базы данных. Но есть и более сложные форматы, позволяющие хранить документы сложной структуры. Каждый формат обладает своим набором
достоинств и недостатков, и для его оценки важны следующие характеристики:
• Способ кодирования — текстовый или двоичный. Текстовый формат легче для восприятия человеком, однако двоичный формат компактнее и требует меньше вычислительных ресурсов для интерпретации. Важно также
помнить, что «человекочитаемость» текстовых форматов сохраняется лишь
для относительно небольших документов, а применение специализированных средств просмотра и отладки позволяет читать двоичные документы.
• Наличие схемы в каждом документе даёт возможность хранить рядом документы совершенно разной структуры, но зато внешнее описание схемы
позволяет существенно сократить объём данных.
• Поддержка сжатия позволяет извлекать из большого документа (или набора документов) только часть, не распаковывая все данные. Если сам по себе
формат не поддерживает сжатие, документ может быть целиком сжат внешними средствами.
• Большинство форматов хранят документы, однако существуют и форматы,
которые группируют вместе отдельные атрибуты документов. Документ такого формата намного сложнее в сохранении, зато поатрибутное, или колоночное, хранение даёт существенный выигрыш при аналитических запросах, где требуется обработать подмножество атрибутов всех документов.
Те же форматы, которые используются для хранения данных, могут использоваться и для передачи данных — например, при удалённом вызове процедур.
В таблице ниже собраны наиболее популярные форматы:
Поатрибутное
Формат Кодирование Схема Сжатие хранение
XML текстовое в документе нет нет
JSON текстовое в документе нет нет
43
Глава 1. Модели данных
Поатрибутное
Формат Кодирование Схема Сжатие хранение
BSON двоичное в документе нет нет
MsgPack двоичное в документе нет нет
Parquet двоичное в файле да да
Avro текстовое, в файле нет нет
двоичное
Protobuf двоичное вне документа нет нет
Thrift двоичное вне документа нет нет
Исторически первый стандарт XML (eXtended Markup Language), опубликованный в 1998 году, является и самым сложным. XML-документ представляет собой текстовый файл, элементы которого размечены тегами — конструкциями,
заключёнными в угловые скобки:
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<person class="physical">
<name>Иванов Василий Петрович</name>
<contacts>
<phone type="mobile">+79995551234</phone>
<phone type="office">+78122128506</phone>
</contacts>
</person>
Информация может содержаться как в самих элементах (например, «Иванов
Василий Петрович»), так и в атрибутах тега (например, атрибут type тега phone,
определяющий тип телефона).
К важнейшим достоинствам XML можно отнести:
• возможность хранения практически любой слабоструктурированной информации — например, договоров или публикаций;
• возможность ставить ссылки между документами;
• возможность описания схемы документа.
Схема XML-документа (XSD — XML Schema Definition) тоже записывается
на языке XML и содержит названия элементов и атрибутов, отношения между элементами и типы данных.
Для иллюстрации приведём одну из возможных схем документа, рассмотренного выше:
44
1.2. Хранилища «ключ—значение»
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="person">
<xs:complexType>
<xs:sequence>
<xs:element type="xs:string" name="name" />
<xs:element name="contacts">
<xs:complexType>
<xs:sequence>
<xs:element name="phone" maxOccurs="5" minOccurs="0">
<xs:complexType>
<xs:simpleContent>
<xs:extension base="xs:string">
<xs:attribute name="type" use="optional">
<xs:simpleType>
<xs:restriction base="xs:string">
<xs:enumeration value="mobile" />
<xs:enumeration value="office" />
<xs:enumeration value="home" />
</xs:restriction>
</xs:simpleType>
</xs:attribute>
</xs:extension>
</xs:simpleContent>
</xs:complexType>
</xs:element>
</xs:sequence>
</xs:complexType>
</xs:element>
</xs:sequence>
<xs:attribute type="xs:string" name="class" use="required" />
</xs:complexType>
</xs:element>
</xs:schema>
Очевидный недостаток XML — его большой объём и огромные затраты вычислительных ресурсов на разбор.
Современные приложения в основном используют XML как транспортный
формат и хранят в базе данных не только образ исходного документа (в основном для разбора инцидентов), но и атомарные значения отдельных полей.
Многие реляционные СУБД, такие как Oracle, PostgreSQL, Db2, Microsoft SQL
Server, позволяют хранить документы в XML и обрабатывать их непосредственно
в базе данных.
Для приложений, основной задачей которых является хранение текстовых документов с относительно небольшим объёмом метаданных (например, база данных научных публикаций или судебных решений), существует подкласс документоориентированных платформ, использующих XML как основной формат хранения данных, — Native XML Databases. К ним относятся MarkLogic, Virtuoso, Oracle
45
Глава 1. Модели данных
Berkeley DB XML и другие1
. Для обработки XML-документов существует мощный
язык запросов XQuery.
Стандарт JSON (JavaScript Object Notation) практически вытеснил XML из целого ряда традиционных ниш. Этому способствовали относительная простота
и компактность формата по сравнению с XML.
Как следует из названия, спецификация JSON — это подмножество синтаксиса
языка JavaScript (точнее, его подмножества ECMAScript). Впервые JSON появился именно в веб-приложениях, потому что для разбора JSON достаточно передать его интерпретатору JavaScript. Сегодня библиотеки для работы с JSON есть
во всех популярных языках программирования.
Объект, описанный выше в XML, в JSON выглядел бы так:
{
"person": {
"class": "physical",
"name": "Иванов Василий Петрович",
"contacts": {
"phones": [
{ "type": "mobile", "number": "+79995551234" },
{ "type": "office", "number": "+78122128506" }
]
}
}
}
Размеры представлений этого конкретного объекта примерно равны, однако
практика показывает, что JSON в среднем на 30 % компактнее.
С распространением JSON также появилась возможность описывать схемы
JSON-документов и автоматически проверять соответствие документа схеме.
В настоящее время стандарт JSON-схемы имеет статус черновика, но достаточно широко используется на практике.
Современные реляционные СУБД позволяют хранить документы в форматах
JSON и обрабатывать их внутри БД.
В отличие от XQuery для XML, сегодня не существует общепризнанного стандарта для языка запросов к JSON-документам. Разные платформы используют
не только разные языки, но и разную семантику сравнения данных. Группой
экспертов, участвовавших в разработке XQuery, предпринята попытка создания
1 Большинство таких платформ поддерживают и другие парадигмы хранения, так что правильнее
назвать их не «XML-платформами», а многовариантными. Подробнее о многовариантности — далее в этом разделе.
46
1.2. Хранилища «ключ—значение»
языка JSONiq (jsoniq.org), претендующего на статус стандарта. Описание языка
доступно под лицензией CC BY-SA1
. Существует несколько движков для выполнения запросов на языке JSONiq, в том числе с открытым исходным кодом.
Формат BSON (Binary JSON) был разработан компанией MongoDB для хранения данных в своей СУБД. BSON очень похож на JSON, однако имеет ряд важных
отличий:
• BSON — двоичный формат: в нём не используются отступы для удобочитаемости и кавычки для экранирования строк. Вместо этого строки завершаются нулевым байтом и дополнительно указывается их длина. Всё это
позволяет уменьшить пространство, занимаемое объектом, и ускорить его
обработку.
• Значения в BSON имеют тип, в отличие от JSON, где тип значения определяется исключительно его написанием (в кавычках — строка, без кавычек —
число или логическое значение). BSON поддерживает типы «дата» и «набор
байтов» (binary), которых нет в JSON, а также позволяет конкретизировать
тип числа — integer, float, long и т. д.
Спецификация BSON опубликована, однако статуса стандарта у неё нет — фактически, это внутренний формат MongoDB. Тем не менее существуют библиотеки для многих популярных языков программирования, позволяющие работать
с этим форматом. Сама MongoDB не предоставляет прямого доступа к своим данным как к BSON-объектам — вместо этого она предоставляет API, позволяющий
манипулировать полями объектов. Кроме того, у этой СУБД есть утилиты, позволяющие выгружать и загружать данные в формате BSON, либо в JSON с некоторыми фирменными расширениями, обеспечивающими более строгую типизацию
данных.
У PostgreSQL есть также формат JSONB, который не совместим с BSON, но зато
обратно совместим с JSON. JSONB не является открытым стандартом, однако позволяет эффективно хранить и обрабатывать JSON-документы. К особенностям
этого формата относятся сжатие незначащих пробелов, сортировка атрибутов
и удаление дубликатов, хранение в разобранном виде с возможностью индексирования. Кроме того, компанией Postgres Professional разработано расширение
zson, выполняющее словарное сжатие JSONB.
1 Лицензия Creative Commons Attribution-ShareAlike позволяет другим перерабатывать, исправлять
и развивать произведение даже в коммерческих целях при условии указания авторства и лицензирования производных работ на аналогичных условиях.
47
Глава 1. Модели данных
Формат MsgPack (Message Pack) также является заменой JSON и позволяет
хранить документы в двоичном представлении. В отличие от BSON, MsgPack является открытым стандартом и используется, например, в Redis и Tarantool/Picodata.
Помимо двоичного кодирования, важным отличием MsgPack от JSON являются так называемые «паскалевские» строки и массивы: вместо того, чтобы определять конец строки или массива по нулевому символу или элементу, в MsgPack
указывается длина строки или количество элементов массива. Такой подход
сложнее в кодировании (сериализации), но проще в декодировании.
Представление данных в JSON, BSON или MsgPack хоть и компактно по сравнению с XML, всё же достаточно объёмно за счёт хранения схемы, то есть имён
(а в BSON — и типов) атрибутов в каждом документе. Для экономии места и ускорения обработки применяются форматы, где схема данных хранится отдельно
от самих данных.
Формат Apache Avro разработан в рамках экосистемы Hadoop и применяется
как транспортный формат при удалённом вызове процедур и как формат для промежуточного хранилища необработанных данных («озеро данных», data lake).
В Avro, как и в MsgPack, при сериализации записывается длина значения, а за
ним — само значение. Порядок, название и типы полей описываются схемой, которая представляет собой документ в формате JSON или в специализированном
формате Avro IDL.
При передаче большого объёма данных схема хранится в заголовке файла,
за которым следует произвольное количество блоков данных. База данных может хранить каждую строку со своей схемой. При этом в начале записи помещается идентификатор схемы, а сами схемы хранятся отдельно от данных. Если Avro
используется в качестве транспортного формата при удалённом вызове процедур, клиент и сервер могут договориться о схеме заранее.
Кроме двоичного кодирования, Avro поддерживает также кодирование в JSON,
но эта возможность используется главным образом при отладке.
Формат Apache Parquet также разработан в экосистеме Hadoop и активно используется в Apache Spark. В отличие от всех рассмотренных ранее форматов,
Parquet хранит данные не по строкам, а по колонкам. Вся таблица делится на группы строк (row groups), и в файл Parquet сохраняются сначала все значения одной колонки для группы строк, затем все значения другой колонки и т. д. Набор
значений колонки, относящихся к одной группе строк, называется фрагментом
(chunk). Каждый фрагмент описывается своими метаданными — тип данных, количество значений, алгоритм сериализации, сжатый и несжатый размеры.
48
1.2. Хранилища «ключ—значение»
Группа строк №1
Группа строк №2
1 2 3 4 5
1 2 3 4 5
6 7 8 9 10
колонки
фрагмент
Такой формат хранения имеет массу преимуществ перед традиционными:
• при выполнении аналитических запросов можно читать не весь файл,
а только те колонки, которые нужны для выполнения запроса;
• благодаря разбиению данных на фрагменты чтение хорошо распараллеливается — в частности, набор данных можно обрабатывать одновременно
на нескольких узлах;
• Parquet — наиболее компактный формат, поскольку для каждой колонки
может быть выбран свой формат сериализации, зависящий от типа данных;
кроме того, значения в колонке, как правило, похожи друг на друга и благодаря этому хорошо сжимаются.
Недостатки формата также очевидны:
• формат не поддерживает разные схемы — скорее, структура файла близка
к таблице реляционной БД;
• единственная возможность изменения схемы — добавление колонки;
• любое изменение данных требует перезаписи файла, поэтому формат
Parquet эффективен для аналитических систем, но совершенно непригоден
для часто изменяемых данных.
Ещё два формата, заслуживающих внимания, — Protobuf и Apache Thrift. Первый разработан и поддерживается Google, второй разработан Facebook1 и передан
в Apache Software Foundation. Протоколы различаются некоторыми деталями —
наборами поддерживаемых типов и языков программирования, возможностями
1 Социальная сеть Facebook принадлежит компании Meta, признанной в России экстремистской организацией. Здесь и далее торговая марка Facebook употребляется исключительно в контексте созданных компанией технологий.
49
Глава 1. Модели данных
расширения и лицензией. В обоих форматах используется двоичная сериализация
(Thrift в отладочных целях допускает также сериализацию в JSON), где данные состоят из тега (идентификатора) поля, его типа и значения. Структура сообщения
описывается при помощи специальных языков (IDL), а затем транслируется в код,
формирующий и читающий сообщения. Основное назначение обоих форматов —
передача параметров при удалённом вызове процедур; для постоянного хранения
данных эти форматы не используются.
Хранилища семейств колонок
Другой путь расширения возможностей хранилищ «ключ—значение» привёл
к появлению ещё одного класса СУБД. Идея, впервые реализованная в СУБД
Google BigTable, заключается в том, что значение, соответствующее ключу, представляет собой множество пар «ключ—значение» или «название колонки — значение колонки». Такие хранилища назвали wide column store, то есть широкое хранилище колонок. Как и следовало ожидать, в таких хранилищах стало появляться
много ключей с одинаковыми наборами значений, и для повышения производительности описание наборов значений стали хранить отдельно от значений и назвали семействами колонок (column families). В англоязычной литературе термины wide column store и column family store используются как синонимы, а в русском
языке закрепился более поздний термин «хранилища семейств колонок».
Наиболее известные платформы этого типа — Google BigTable, Apache HBase,
Apache Cassandra и её коммерческая версия DataStax Enterprise, а также ScyllaDB.
Чтобы начать работу с хранилищем семейств колонок, нужно создать пространство ключей (keyspace — в Cassandra, table — в HBase) — аналог базы
данных в реляционных БД. Пространство определяет параметры хранения данных, — такие как количество реплик каждого элемента и набор серверов, где
они будут храниться. В пространстве создаются семейства колонок (column families) — наборы колонок, каждая из которых имеет определённый тип.
Легче всего представить себе семейство колонок как электронную таблицу —
например, книгу Microsoft Excel®. Пространство соответствует книге, а семейство колонок — листу. Лист очень похож на таблицу — настолько, что в СУБД
Cassandra с 2011 года используется термин table вместо термина column family.
Если в HBase используется Java API и REST API, основанный на JSON, то в платформах Cassandra и ScyllaDB используется язык CQL (Cassandra Query Language),
очень похожий на язык SQL. Тем не менее хранилище семейств колонок не является реляционной базой данных:
50
1.2. Хранилища «ключ—значение»
• В отличие от таблицы в реляционной базе, семейство колонок обязано
иметь первичный ключ. Эта модель представления данных проектировалась
с прицелом на распределённое хранение, и первичный ключ (точнее, его
часть) определяет узлы, где будут храниться соответствующие ему данные.
• Как и в документоориентированных БД, хранилище семейств колонок не
предусматривает операций над несколькими таблицами, поэтому для хранения сложных структур данных широко используются композитные типы — множества, списки, ассоциативные массивы. Если использовать терминологию реляционных БД, то семейство колонок не находится в первой
нормальной форме.
• Данные в хранилище упорядочены. Если в реляционных БД основным инструментом ускорения доступа к данным является построение вторичных
индексов, то в семействах колонок в первую очередь нужно определить
именно порядок строк.
• В отличие от реляционных БД, колонки в семействе упорядочены. Это отличие скорее теоретическое, потому что, несмотря на отсутствие порядка
атрибутов в отношении, колонки в таблице реальной реляционной БД обычно располагаются в порядке их перечисления в команде CREATE TABLE.
Если в HBase первичный ключ представляет собой набор байтов, который приложение должно как-то интерпретировать, то в таких платформах, как Cassandra
и ScyllaDB, использующих CQL, первичный ключ — это типизированная колонка
или набор колонок.
Ключ из единственного поля ничем не отличается от обычного ключа в «чистой» платформе класса «ключ—значение» или в документоориентированной
платформе. Но если ключ составной, то разные части ключа выполняют разные
функции.
Первое поле (или несколько полей) составляет ключ размещения (partitioning
key). Платформа гарантирует, что все данные, у которых значения этого ключа
совпадают, будут храниться на одном узле1
. Остальные поля, входящие в первичный ключ, составляют ключ кластеризации (clustering key). Данные упорядочены
в соответствии со значениями ключа кластеризации.
При использовании составного ключа у семейств колонок появляется возможность использовать статические колонки (static columns), значение которых
1 Корректнее будет сказать «попадут в один шард». Подробнее о шардировании — в главе 3 «Структуры хранения данных».
51
Глава 1. Модели данных
Семейство колонок
Первичный ключ
Ключ
размещения
Значение
Статическая
колонка
Значение
Ключ
кластеризации
Значение
Колонка
Значение
Ключ
кластеризации
Значение
Колонка
Значение
одинаково для всех значений ключа размещения. Когда ключ состоит из единственного поля, все колонки можно считать статическими. По сути семейство
колонок представляет собой соединение двух таблиц, одна из которых подчинена
другой (master-detail).
Пусть, например, у нас есть база данных торговой компании, и в этой базе хранятся накладные. Идентификатором (ключом) накладной может служить набор
(идентификатор клиента; номер накладной), причём идентификатор клиента будет ключом размещения, а номер накладной — ключом кластеризации. Контактная информация клиента может храниться в статических колонках.
Языки запросов к семействам колонок предоставляют те же возможности,
что и интерфейсы документоориентированных БД, — возврат части атрибутов,
поиск по значениям неключевых атрибутов и поддержка вторичных индексов.
Так же, как и документоориентированные платформы, семейства колонок не поддерживают операции с несколькими наборами данных — соединения, объединения, пересечения и др.
БД временных рядов
Ещё одна ветвь эволюции хранилищ «ключ—значение» — базы данных временны́х рядов (time series databases). Это специализированные платформы, предназначенные для хранения событий — например, данных системы мониторинга
или результатов опроса датчиков. У таких наборов данных и запросов к ним есть
особенности, которые учитываются при разработке:
• Ключ может содержать несколько полей — например, номер объекта и номер датчика. Как и в семействах колонок, пользователь имеет возможность
52
1.3. Другие модели данных
на уровне описания данных указать, какие из этих полей влияют на место
хранения событий (записей).
• Ключ обязательно содержит временну́ю метку.
• Данные делятся на два типа: собственно метрики событий и дополнительная информация о ключе — метки (tags). Например, вместе с номером объекта мы можем хранить его адрес, чтобы впоследствии анализировать информацию не по одному объекту, а по группе соседних объектов. Для выполнения таких запросов платформа предоставляет возможность индексирования меток.
• В целях экономии ресурсов данные со временем будут агрегированы. Следовательно, в качестве измерений необходимо уметь хранить не только скалярные значения, но и разного рода агрегаты — от количества измерений
и среднего значения до гистограмм.
• Для БД временны́х рядов характерны запросы истории изменения набора
параметров в течение заданного времени с определённым шагом, не обязательно совпадающим с шагом измерения значений. Следовательно, платформа должна быстро и эффективно выполнять пересчёт и сопоставление
временны́х меток, агрегацию и ранжирование показателей. И, разумеется,
предоставлять удобный интерфейс для этих операций.
Кроме того, есть и другие особенности работы этих платформ, влияющие
не столько на модель данных, сколько на механизм хранения. Например, данные
очень быстро записываются, но никогда не обновляются, а по истечении некоторого времени все данные со старыми временны́ми метками удаляются.
Наиболее известные платформы этого класса — InfluxDB, Prometheus, Graphite, TimescaleDB, OpenTSDB.
1.3. Другие модели данных
Объектные БД
В основе объектных баз данных лежит идея построить платформу для хранения и обработки данных на принципах объектно-ориентированного программирования.
Объектная модель имеет много общего с реляционной, и между терминами
объектной и реляционной моделей есть прямое соответствие:
53
Глава 1. Модели данных
В объектной В объектной В реляционной В реляционной
модели модели модели модели
(английский (русский (английский (русский
термин) термин) термин) термин)
Package Пакет Schema Схема
Class Класс Table Таблица
Object instance Объект Row Строка (запись) (экземпляр класса)
Property Свойство Column Колонка (поле)
Relationship Отношение (ссылка) Foreign key Внешний ключ
Embedded object Встроенный объект Multiple columns Набор колонок
Method Метод Stored procedure Хранимая
процедура
По замыслу создателей объектных БД объектный интерфейс должен был упростить интерфейс между базой данных и приложением за счёт отказа от библиотек, представляющих реляционные данные как объекты (ORM, object-relationnal
mapping), а кроме того — повысить производительность выполнения запросов
за счёт унификации моделей данных при обработке (в приложении) и хранении
(в базе).
На практике широкого распространения объектные базы данных не получили: в первой сотне рейтинга, рассчитываемого сайтом db-engines.com, находится
всего одна такая платформа — InterSystems Caché. Библиотеки же класса ORM,
наоборот, используются весьма широко: для Java существуют Hibernate, EclipseLink и более десятка менее распространённых библиотек; для .NET, кроме библиотеки Entity Framework, включенной в .NET Framework, существует более десятка библиотек, поддерживаемых независимыми разработчиками. Существуют также ORM-библиотеки для PHP (включая те, что входят в состав Yii и Zend
Framework), для Python (включая ту, что входит в Django), для Perl, Ruby и других
языков.
Одна из главных проблем объектной модели состоит в том, что инкапсуляция, один из принципов объектной парадигмы, подразумевает, что приложение
вместо полного доступа к структуре данных может выполнять только набор разрешённых операций над объектами. А это в свою очередь подразумевает активное использование хранимого кода в БД или разработку для каждого языка про54
1.3. Другие модели данных
граммирования библиотек, учитывающих особенности объектной модели языка
и совмещающих модель языка с моделью конкретной базы данных.
Представляет интерес история публикаций, посвящённых объектным платформам. В 1989 году на конференции в Киото группой учёных под руководством
профессора Школы информатики Эдинбургского университета Малколма Аткинсона (Malcolm Atkinson) был сделан доклад под названием «Манифест систем
объектно-ориентированных баз данных» («The Object-Oriented Database System
Manifesto»). Но уже в 1990 году был опубликован «Манифест СУБД третьего поколения» («Third-Generation Data Base System Manifesto»), где одним из требований к новым платформам было сохранение всех возможностей старых, то есть
реляционных, которые отнесены ко второму поколению. Второй манифест был
написан группой исследователей под руководством великого Майкла Стоунбрейкера (Michael Stonebraker). Его можно считать реакцией индустрии на революционные предложения первого манифеста. Вкратце, по мнению авторов второго
манифеста, все новые возможности можно получить, не производя революцию
в области технологии баз данных, а эволюционно развивая традиционные реляционные платформы.
Графовые БД
Графовые базы данных — прямые наследники сетевых баз. Данные здесь представлены в виде графов: объекты являются узлами, а связи между ними — рёбрами. Графовые БД, как и реляционные, имеют развитые средства декларативного
описания предметной области.
Каждый узел (объект) может иметь метки. Например, на рисунке ниже все
узлы, обозначающие клиентов, имеют метку :Client и дополнительную метку,
:Person или :Organization, определяющую тип клиента. Метки не фиксированы,
их можно ставить и убирать. Так, например, если обслуживание клиента приостановлено, ему можно поставить метку :Suspended, а при возобновлении обслуживания метку можно будет убрать. Метки нужны для выделения классов узлов.
Между объектами существуют отношения1
(рёбра). У отношения обязательно есть направление и название. На рисунке ниже мы видим отношения «владеет» (owns), «дружит_с» (is_friend_of), «работает_в» (works_in). Запросы могут
1 Термин «отношения» в графовых СУБД не имеет ничего общего с отношениями в реляционных
платформах. Но с точки зрения теории множеств множество рёбер в графовой базе является отношением третьей (или больше) степени.
55
Глава 1. Модели данных
:Client:Person
id = 42
name = "Василий"
:Client:Person
id = 91
name = "Мария"
:Account
id = 1001
Amount = 10000
owns
:Client:Organization
id = 88
tax_no = 1234567890
is_friend_of
date = 2020-08-03
works_in
position = "manager"
учитывать или не учитывать направление отношения: например, мы всегда считаем Василия другом Марии, но в зависимости от логики запроса можем считать
или не считать Марию подругой Василия.
У узлов и отношений могут быть атрибуты — наборы пар «ключ—значение»,
представляющие данные, связанные с узлом или отношением.
Графовые БД, как и реляционные, позволяют определить декларативные ограничения целостности:
• Существование атрибута. Атрибут с заданным именем должен существовать у всех узлов с заданной меткой или у всех отношений (рёбер) заданного типа.
• Уникальность атрибута. Значение атрибута должно быть уникальным среди всех узлов с заданной меткой. При этом атрибут не обязан существовать.
• Первичный ключ узла. Атрибут (или набор атрибутов) узла обязан существовать, а его значения (или наборы значений) обязаны быть уникальными.
Графовые базы позволяют создавать индексы по атрибутам узлов.
В основном графовые базы используются для разного рода аналитики, в том
числе в реальном времени — анализа социальных сетей, рекомендации товаров
и контента, предотвращения мошеннических операций, поддержки баз знаний.
Для написания запросов к графовым базам созданы декларативные языки.
В отличие от SQL, который де-юре и де-факто является стандартом для реляционных платформ, для графовых баз создано несколько языков, отличающихся друг
от друга синтаксисом и набором возможностей:
56
1.4. Сравнение моделей данных
Язык В каких платформах используется
Cypher Neo4j, Agens Graph, AnzoGraph, CAPS: Cypher for Apache Spark,
Memgraph
Gremlin Neo4j, Microsoft Azure CosmosDB, OrientDB, JanusGraph, Amazon
Neptune, Giraph, InfiniteGraph
SPARQL Amazon Neptune, Virtuoso, AllegroGraph, Blazegraph
В 2019 году комитет ISO/IEC принял предложение о создании стандарта GQL —
языка запросов к графовым БД, во многом основанном на Cypher.
Важное отличие графовых БД от реляционных состоит в том, что результатом
выполнения запроса не обязательно является граф: это может быть и граф, и набор узлов, и таблица с набором атрибутов.
1.4. Сравнение моделей данных
После рассмотрения такого множества подходов к представлению данных возникает вопрос: какая же модель лучше? В таблице ниже приведены ключевые
особенности рассмотренных моделей:
Реляци- Ключ— Доку- Семейство Времен- Объектонная значение ментная колонок ные ряды ная Графовая
Поиск по ключу + + + + + + +
Хранение слабоструктурирован- + + + + − − −
ных данных
Извлечение
или обновление + − + + + + +
части атрибутов
Поиск
по неключевым + − + + − + +
атрибутам
Составной ключ + − − + + + +
Связи между + − − − − + +
сущностями
Стандартный + + − − − − ± интерфейс
57
Глава 1. Модели данных
Из таблицы очевидно, что с точки зрения возможностей манипулирования
данными реляционная модель — наиболее универсальная среди всех рассмотренных. Специализированные возможности, которых в реляционных СУБД нет
«из коробки», могут быть реализованы при помощи языка SQL или его процедурных расширений, которые есть во всех современных платформах. Так, например,
базы временны́х рядов в тестах регулярно сравниваются с реляционными и не
всегда побеждают даже на тех специфических задачах, для которых изначально
созданы.
Важным преимуществом реляционной модели является компактность хранения: структура таблицы, описывающая названия и типы колонок, хранится один
раз для таблицы, в отличие, например, от документоориентированной модели,
где имена полей хранятся в каждом документе.
В статьях и обсуждениях на форумах в качестве преимущества реляционной
модели данных называется поддержка транзакций. Как мы увидим в главе 5
«Гарантии корректности данных», транзакции не связаны с моделью данных,
и упомянутые заявления попросту безграмотны. Корни этого заблуждения растут
из рекламных материалов ранних NoSQL баз данных, где отсутствие транзакций
подавалось как преимущество. Рынок такого «преимущества» не оценил, что вынудило разработчиков пересматривать гарантии целостности, предоставляемые
их платформами.
Тем не менее нереляционные базы данных используются широко, и с каждым
годом их популярность растёт. В чём же недостатки реляционной модели?
О первом недостатке мы уже упоминали: реляционная модель плохо приспособлена для горизонтального масштабирования, поскольку язык SQL, интерфейс реляционной базы, не предусматривает обязательного указания первичного ключа строки, а потому клиент не может предсказать, где находятся данные,
которые потребуются запросу, и какой узел должен выполнить этот запрос.
Второй недостаток — сложность изменения схемы данных. В те годы, когда
реляционные базы данных только создавались, это не было проблемой, поскольку программное обеспечение создавалось по «водопадной» модели, где процесс
проектирования предшествует процессу разработки, а весь цикл выпуска новой
версии приложения растянут во времени. Современные методики разработки
предполагают постоянное перепроектирование, которое может потребовать изменения модели данных. В хранилищах «ключ—значение» изменение модели
не является событием — просто с какого-то момента в базе появляются объекты новой структуры. В реляционной же базе изменение структуры таблицы —
58
Литература
отдельная команда, выполнение которой может привести даже к приостановке
работы приложения. Правда, современные платформы научились выполнять эти
команды достаточно эффективно.
Литература
• Comparison of hierarchical and relational databases.
www.ibm.com/docs/en/ims/15.1.0?topic=ims-comparison-hierarchical-relational-databases
• Эдгар Кодд. Реляционная модель данных для больших совместно
используемых банков данных.
citforum.ru/database/classics/codd/
• Кристофер Дж. Дейт. Введение в системы баз данных (Introduction to
Database Systems). 8-е изд. — М.: Вильямс, 2005. — 1328 с. —
ISBN 5-8459-0788-8 (рус.) 0-321-19784-4 (англ.).
• Java Temporary Caching API Compatible Implementations.
jcp.org/aboutJava/communityprocess/implementations/jsr107/index.html
• William Zola. 6 Rules of Thumb for MongoDB Schema.
www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-1
• Ирина Блажина. JSON Schema. Быть или не быть?
habr.com/ru/post/495766/
• JSON and BSON.
www.mongodb.com/json-and-bson
• Rahul Bhatiar. Форматы файлов в больших данных: краткий ликбез /
пер. Андрея Пшеничнова.
habr.com/ru/company/mailru/blog/504952/
• Shilpi Gupta. Двоичное кодирование вместо JSON (перевод выполнен
специалистами школы SkillFactory).
habr.com/ru/company/skillfactory/blog/509902/
• Sylvain Lebresne. A thrift to CQL3 upgrade guide.
www.datastax.com/blog/thrift-cql3-upgrade-guide
• Jonathan Ellis. Does CQL support dynamic columns / wide rows?
www.datastax.com/blog/does-cql-support-dynamic-columns-wide-rows
• Jim Wilson. Understanding HBase and BigTable.
dzone.com/articles/understanding-hbase-and-bigtab
59
Глава 1. Модели данных
• Apache HBase™ Reference Guide.
hbase.apache.org/book.html
• Александр Петров. Big Data от А до Я. Часть 4: Hbase.
habr.com/ru/company/dca/blog/280700/
• Klara Oswald. Знакомство с InfluxDB и базами данных временных рядов.
tproger.ru/translations/influxdb-guide/
• Полное руководство по Prometheus в 2019 году.
habr.com/ru/company/southbridge/blog/455290/
• Baron Schwartz. Time-Series Database Requirements.
www.xaprb.com/blog/2014/06/08/time-series-database-requirements/
• Introduction to Caché.
docs.intersystems.com/latest/csp/docbook/pdfs/pdfs/GIC.pdf
• Сергей Кузнецов. Три манифеста баз данных: ретроспектива
и перспективы.
citforum.ru/database/articles/manifests/
• The Neo4j Getting StartedGuide v4.2.
neo4j.com/docs/pdf/neo4j-getting-started-4.2.pdf
60
Глава 2
Другие методы классификации
баз данных
Селянская классификация нежити несколько отличалась
от общепринятой магической, включая всего три вида:
«вупыр», «вомпэр» и «щось такэ зубасто».
Ольга Громыко, «Верховная ведьма»
Модель данных, применяемая в какой-либо платформе, не является её единственной и исчерпывающей характеристикой. Не менее важными характеристиками являются:
• тип нагрузки, на которую рассчитана платформа;
• возможность работы на нескольких серверах одновременно;
• среда хранения данных — диск или оперативная память.
2.1. Аналитические и транзакционные БД
База данных может применяться либо для обработки транзакций, либо для
анализа информации. Традиционно эти два типа нагрузки называются «транзакционный» (OLTP — online transaction processing) и «аналитический» (OLAP —
online analytical processing). Некоторые производители пытаются позиционировать свои платформы как «гибридные» (HTAP — hybrid transactional/analytical
processing), однако практика показывает, что специализированные решения
всегда выигрывают у универсальных.
Различия между типами нагрузки можно представить в виде таблицы:
61
Глава 2. Другие методы классификации баз данных
Показатель Обработка транзакций Аналитика
Интенсивность операций от десятков до десятков тысяч от единиц до сотен
операций в секунду операций в секунду
Время исполнения от десятков миллисекунд от секунд до часов
операции до секунд
Количество объектов, от единиц до тысяч от десятков тысяч
обрабатываемых операцией до миллиардов
Соотношение записи от 100:1 в пользу чтения от 1000:1 до 106
:1
и чтения до 100:1 в пользу записи в пользу чтения
Использование колонок все небольшое
при выполнении операции подмножество
Сложность запросов низкая высокая
низкое высокое
Разнообразие запросов (типовые запросы) (специализированные запросы)
Перечисленные различия требуют различных архитектурных решений, оптимизированных для разных задач.
Транзакционные БД кешируют часто используемые объекты. При обработке
аналитических запросов кеширование бесполезно, т. к. объём данных, читаемых
за одну операцию, может превышать размеры кеша; вместо этого оперативную
память целесообразно использовать для сортировки данных.
Операция фиксации транзакции (commit) в транзакционной СУБД должна
быть быстрой и недорогой, т. к. количество транзакций сравнимо с количеством
обновляемых объектов. В аналитических БД каждая пишущая транзакция обновляет тысячи или даже миллионы записей, поэтому такие платформы могут позволить себе долгую фиксацию, если это уменьшит общее время записи данных.
Структуры данных в транзакционных БД должны поддерживать быстрое чтение и изменение отдельных объектов с минимальным влиянием на остальные
объекты, пусть даже ценой увеличения общего объёма чтения и хранения данных (read/space amplification). Аналитическая БД, наоборот, должна хранить
данные наиболее компактно и обеспечивать быстрое считывание всего массива данных, но может позволить существенное удорожание операций записи
(write amplification). Транзакционная СУБД вынуждена оставлять свободное место в файле для записи новых версий объекта при увеличении размера полей или
хранить несколько версий объекта. Аналитическая СУБД, напротив, может сор62
2.2. Монолитные и распределённые БД
тировать и сжимать данные при записи. Некоторые аналитические СУБД не поддерживают операцию обновления (update) данных — для обновления необходимо явно удалить (delete) старые данные и записать (insert) новые.
2.2. Монолитные и распределённые БД
Первые системы управления базами данных были рассчитаны на работу на одном сервере. Единственным способом увеличения производительности такой
платформы является увеличение производительности сервера. Очевидно, что
она не бесконечна.
Сейчас, когда обыкновенный типовой (commodity) сервер является настоящим суперкомпьютером по меркам двадцатилетней давности, есть другая проблема: стоимость сервера зависит от его мощности нелинейно. Если открыть
конфигуратор на сайте одного из ведущих мировых производителей серверного
оборудования и попробовать сконфигурировать серверы разной вычислительной мощности, то получим такую картину (цены приведены в «условных единицах» с тем расчётом, чтобы стоимость сервера начального уровня составляла
1000 у. е.):
2-сокетный 4-сокетный 8-сокетный
сервер сервер сервер
Количество ядер 32 64 128
Объём оперативной памяти, ГБ 256 512 1 024
Объём дисков, ГБ 480 960 1 920
Стоимость, у. е. 1 000 2 286 7 834
Наглядно соотношение стоимости представлено на диаграмме ниже (цветом
выделен вклад в общую стоимость шасси, процессоров, памяти и дисков):
0 2 000 4 000 6 000 8 000 10 000 12 000 14 000 16 000 18 000
2xCPU
4xCPU
8xCPU
63
Глава 2. Другие методы классификации баз данных
Если вместо 16-ядерных процессоров использовать 28-ядерные1
, картина будет следующая:
2-сокетный 4-сокетный 8-сокетный
сервер сервер сервер
Количество ядер 56 112 224
Объём оперативной памяти, ГБ 512 1 024 2 048
Объём дисков, ГБ 480 960 1 920
Стоимость, у. е. 2 705 8 277 16 508
Диаграмма вклада шасси, процессоров, памяти и дисков выглядит так:
0 2 000 4 000 6 000 8 000 10 000 12 000 14 000 16 000 18 000
2xCPU
4xCPU
8xCPU
Помимо маркетинговых соображений, у нелинейной зависимости стоимости
сервера от максимального количества процессоров есть и технологические причины: от количества сокетов зависит сложность и стоимость как чипсета, так
и самого процессора. На второй диаграмме восьмисокетный сервер всего вдвое
дороже четырёхсокетного, поскольку в обеих конфигурациях использованы одинаковые процессоры из-за более бедной номенклатуры 28-ядерных чипов. Для четырёхсокетного сервера можно было бы использовать, например, более дешёвые
26-ядерные процессоры, но тогда сравнение было бы не совсем корректным.
Не удивительно, что стали появляться системы, способные к горизонтальному
масштабированию, то есть к увеличению мощности за счёт одновременной работы на нескольких серверах. Одними из первых распределённых систем являются
Tandem NonStop2
(1976) и Teradata (1979).
1 Количество ядер выбрано с тем расчётом, чтобы была возможность собрать любую конфигурацию
от двух до восьми сокетов.
2 Куплен компанией Hewlett-Packard.
64
2.2. Монолитные и распределённые БД
Возможность масштабирования на дешёвом оборудовании весьма привлекательна, однако она требует совершенно иного подхода к разработке СУБД, т. к.
распределённая система сталкивается с целым рядом проблем, нехарактерных
для монолитной системы:
• межпроцессные коммуникации дороги, т. к. сообщение может идти по сети и для обеспечения высокой производительности количество сообщений
должно быть минимизировано;
• из-за сетевых отказов межпроцессные коммуникации ненадёжны, поэтому
система должна быть готова к потере части сообщений;
• у разных процессов, обслуживающих одну и ту же систему, может быть разное локальное время;
• часть узлов, а вместе с ними и часть процессов (а иногда и часть данных) могут исчезнуть, и система должна штатно реагировать на подобные ситуации;
• узлы могут разделиться на два (или больше) несвязанных подмножества,
внутри которых узлы сохраняют связь между собой; получается два независимых кластера, каждый из которых может продолжить работу, считая, что
часть узлов потеряна.
Перечисленные проблемы более или менее успешно решаются, и позже мы
поговорим об используемых при этом алгоритмах. Однако позиции монолитных
СУБД по-прежнему прочны, и нет никаких предпосылок к их исчезновению.
Отдельным подклассом распределённых платформ можно считать облачные
базы данных (cloud-only database). Дистрибутивы или исходный код таких платформ нельзя скачать и развернуть на своём оборудовании; можно получить только базу данных как услугу в облаке.
Облачные базы данных обладают рядом технических преимуществ. Во-первых,
они могут быть сколь угодно сложными, поскольку рассчитаны на эксплуатацию
не администраторами средней квалификации, а людьми, имеющими непосредственный контакт с разработчиками платформы. Во-вторых, облачная база данных может рассчитывать на любые особенности инфраструктуры — особые сетевые топологии и нестандартные протоколы, специализированные конфигурации
серверов или наличие уникального оборудования — например, атомных часов.
Разработкой облачных баз занимаются крупные провайдеры облачных услуг.
Примерами таких платформ могут служить Google BigTable, Google Spanner, Amazon DynamoDB, Amazon Aurora, Azure CosmosDB, YDB1
.
1 Исходный код YDB доступен с 2022 года под лицензией Apache 2.0.
65
Глава 2. Другие методы классификации баз данных
2.3. БД на диске и в памяти
Традиционные платформы хранения и обработки данных появились в то время, когда оперативная память была дорога, а объёмы памяти были весьма скромными. Так, например, объём памяти флагманского мейнфрейма Model 195 серии IBM System/360, выпущенного в 1969 году, мог достигать 4 МБ. Естественно,
СУБД того времени могли хранить данные только на дисках, загружая их в память
небольшими порциями.
Доллары за МБ
1955 1960 1965 1970 1975 1980 1985 1990 1995 2000 2005 2010 2015 2020 2025
10−3
10−2
10−1
100
101
102
103
104
105
106
107
108
109
Триггеры
Сердечники
Микросхемы
SIMM
DIMM
За 50 лет объём памяти в серверах вырос на шесть порядков, а на графике,
построенном по данным сайта jcmit.net (шкала логарифмическая), видно, что
стоимость памяти за это же время упала на восемь порядков. Естественным образом возникло желание создать платформы, хранящие и обрабатывающие данные
непосредственно в оперативной памяти и использующие диск исключительно
для восстановления данных после аварий.
Идея «взять обычную СУБД и просто дать ей больше памяти» выглядит заманчиво, но работает плохо. Дело в том, что в дисковых СУБД вся архитектура подчинена тому, чтобы оптимизировать работу с диском, и когда производительность
дисковой подсистемы перестаёт быть узким местом, система упирается в другие
66
2.3. БД на диске и в памяти
ограничения, которые не снимаются увеличением мощности оборудования. Обратим внимание лишь на некоторые проблемы.
• Дисковое представление данных может содержать пустое пространство: вопервых, данные выравниваются по границе блока, но могут не занимать
блок целиком, а во-вторых, СУБД может намеренно оставлять запас пространства на случай увеличения размеров полей, хранящихся в блоке. Очевидно, что и в оперативной памяти это место будет пустым, хотя его можно
было бы использовать.
• Дисковые СУБД используют оперативную память как кеш, то есть адрес блока в памяти никак не связан с его положением в базе данных. Вместо этого СУБД вынуждена хранить таблицу соответствия между физическим адресом блока и его положением в кеше. Практика показывает, что начиная
с некоторого объёма1
эффективность кеша падает, т. к. выигрыш от уменьшения обмена с диском уравновешивается накладными расходами на поиск
данных в кеше.
Группа учёных под руководством Майкла Стоунбрейкера провела исследование, на что дисковая СУБД тратит ресурсы процессора. Результаты получились ошеломительными: полезная нагрузка по обработке данных составила чуть
меньше 7 %! Остальные ресурсы процессора расходуются на управление буферами (buffer management), обеспечение конкурентного доступа к дисковым структурам (latching) и логическим записям (blocking), журналирование (logging)2
.
6,8 % Полезная работа
Неоптимальный код
16,2 %
Журналирование
Блокировки 11,9 %
16,3 %
Конкуренция за страницы
14,2 %
Управление буферами
34,6 %
1 Конкретный объём зависит от СУБД. Например, для Oracle он составляет 1–2 ТБ.
2 Эксперимент проводился на модельной СУБД с открытым исходным кодом. На промышленных
платформах распределение, вероятно, иное.
67
Глава 2. Другие методы классификации баз данных
Первая коммерческая СУБД, содержавшая движок для хранения и обработки данных в памяти, solidDB, появилась в 1992 году, и совсем немного отстал
стартап TimesTen, основанный в 1996 году и купленный в 2005 году корпорацией Oracle. В первой декаде нового тысячелетия появилось множество платформ,
предоставляющих распределённый кеш в памяти (Memcached, Redis), а также
встраиваемых библиотек для организации распределённого кеша внутри приложения (GigaSpaces XAP, Terracotta Ehcache, Hazelcast, GridGain). В 2010-х годах были созданы полноценные СУБД в памяти — VoltDB, SAP HANA, Tarantool, Picodata.
Оперативная память по-прежнему на три порядка дороже, чем диски, поэтому уход с рынка дисковых СУБД в обозримом будущем вряд ли произойдёт. Однако возможно, что нас ждёт очередная революция, связанная с расширением
номенклатуры систем хранения данных. Если раньше разработчикам были доступны только диски и оперативная память, то сегодня появился как широкий
выбор дисковых устройств, существенно различающихся по своим характеристикам, так и энергонезависимая память (SCM, storage-class memory), например Intel
Optane. Энергонезависимая память занимает промежуточное положение по стоимости и производительности между оперативной памятью и дисками. На диаграмме ниже показана задержка (latency) при доступе к разным видам памяти.
10−9
10−8
10−7
10−6
10−5
10−4
10−3
10−2
10−1
10–50 нс
Оперативная память
(DDR5 SDRAM)
SCM DIMM (Intel Optane) 100–300 нс
NVMe flash 10–30 мкс
SAS SSD 100–300 мкс
SAS HDD 15K об/мин 5–7 мс
SAS HDD 7200 об/мин 15–20 мс
2.4. Карта баз данных
Попытаемся классифицировать широко известные платформы по перечисленным признакам: модель данных, возможность горизонтального масштабирования, тип нагрузки, среда хранения:
68
2.4. Карта баз данных
Монолитные Монолитные Распределённые Распределённые
дисковые в памяти дисковые в памяти
Реляционные Oracle, Oracle TimesTen, Teradata, Greenplum, SAP HANA,
PostgreSQL, SAP HANA, SAP IQ, Vertica, Exasol,
Microsoft SQL solidDB ClickHouse, Picodata,
Server, Db2, Google Spanner, SingleStore
MySQL, Oracle Real (бывший MemSQL),
SQLite Application Cluster, Oracle TimesTen
Oracle with Sharding Scaleout IMDB,
Option, VoltDB
IBM PureData System
for Transactions,
HPE NonStop SQL,
CockroachDB,
YugabyteDB,
YDB
Ключ— GT.M, RocksDB, Riak KV, Redis, Hazelcast,
значение Berkeley DB Project Voldemort Memcached, etcd,
Terracotta Ehcache,
Aerospike,
GridGain/Apache
Ignite, Infinispan,
Oracle Coherence,
Pivotal GemFire/
Apache Geode,
Tarantool,
WebSphere
eXtreme Scale
Документо- MongoDB,
ориентиро- Elasticsearch,
ванные Amazon DynamoDB,
Couchbase,
CouchDB, MarkLogic,
Oracle NoSQL
Семейства Cassandra, HBase,
колонок Google BigTable,
ScyllaDB,
Apache Accumulo
Временные Graphite, kdb+ InfluxDB, Prometheus,
ряды TimescaleDB VictoriaMetrics
Графовые Amazon Neptune Memgraph Neo4j, ArangoDB,
OrientDB, JanusGraph
69
Глава 2. Другие методы классификации баз данных
На полученной карте видно несколько аномалий:
• практически все платформы класса «ключ—значение» распределённые; более бедная (относительно реляционной) модель данных является платой
за относительную простоту разработки распределённой системы;
• все аналитические системы (выделены жирным шрифтом) — реляционные;
это прямое следствие того, что реляционная модель даёт наиболее мощные
инструменты анализа данных.
Карту полезно держать перед глазами, чтобы исключить сравнение несравнимых платформ — например, «PostgreSQL vs. Redis» или ещё лучше «БД в памяти vs. реляционные БД» (дословная цитата из статьи в одном из блогов на сайте
habr.com).
Тем не менее необходимо помнить, что эта карта, как и любая классификация,
достаточно условна.
Условно деление по модели данных.
В 2011 году Мартин Фаулер опубликовал статью «Многовариантное хранение»
(«Polyglot persistence»). По словам Фаулера, будущее — за теми платформами, которые могут предложить пользователям несколько разных интерфейсов для хранения разных данных в рамках комплексного решения сложной задачи.
Многие популярные современные платформы поддерживают несколько моделей данных. Например, Aerospike и Tarantool, которые позиционируются как
хранилища «ключ—значение», поддерживают обращение к отдельным полям.
Документоориентированная Couchbase наряду с Aerospike поддерживает вторичные индексы. Такие платформы, как GridGain, Pivotal GemFire, даже поддерживают язык SQL, а Picodata, бывшая поначалу форком Tarantool, стала полноценной реляционной платформой. Реляционные Oracle и PostgreSQL поддерживают хранение XML и JSON с обработкой документов на сервере, а также работу
с графами1
.
Условно деление по типу нагрузки. Некоторые платформы (например, SAP
HANA или SingleStore) содержат несколько движков разного назначения, а Oracle
в зависимости от настроек экземпляра может эффективно работать и как транзакционная, и как аналитическая платформа. Графовые СУБД используются преимущественно для анализа данных, но при этом выполняется множество мелких
читающих запросов — как при обработке транзакций.
1 Работа с графами реализована в СУБД AgensGraph, базирующейся на PostgreSQL.
70
Литература
Условно деление по возможности горизонтального масштабирования. В категорию распределённых попадают как классические платформы, работающие
на полностью независимых узлах (архитектура «shared nothing»), так и платформы с общим дисковым пространством (архитектура «shared disk» — Oracle RAC,
HPE NonStop, Vertica).
Условно деление по среде хранения. Многие классические дисковые СУБД
(Oracle, Microsoft SQL Server) получили движки для обработки данных в памяти, в то время как платформы, работающие в памяти (solidDB, GridGain,
Tarantool, MemSQL/SingleStore), обзавелись подсистемами хранения на дисках.
Есть и платформы, которые с самого начала разрабатывались как гибридные —
например, kdb+.
Даже само понятие «система управления базами данных» весьма условно. Помимо платформ, реализующих полный набор механизмов хранения и обработки
данных, в карту попали встраиваемые системы (SQLite, Berkeley DB, RocksDB),
а также надстройки над существующими платформами, обеспечивающие дополнительные модели обработки данных (JanusGraph, Prometheus, Graphite, TimescaleDB, Project Voldemort).
Для тех, кто желает самостоятельно классифицировать СУБД и исследовать
родственные взаимоотношения разных платформ, настоящей находкой станет
сайт «База баз» (Database of Databases) dbdb.io.
